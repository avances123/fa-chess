import os
import json
import time
from datetime import datetime
import chess
import polars as pl
from PySide6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                             QTableWidget, QTableWidgetItem, QLabel, QPushButton, 
                             QFileDialog, QProgressBar, QHeaderView, QTextBrowser, 
                             QStatusBar, QTabWidget, QListWidget, QListWidgetItem, QMenu, 
                             QColorDialog, QMenuBar, QAbstractItemView, QToolBar, 
                             QStyle, QSizePolicy, QMessageBox, QApplication)
from PySide6.QtCore import Qt, QPointF, QTimer, QSize
from PySide6.QtGui import QAction, QFont, QShortcut, QKeySequence, QPainter, QColor, QBrush
import qtawesome as qta

from src.config import CONFIG_FILE, LIGHT_STYLE, ECO_FILE
from src.core.workers import PGNWorker, StatsWorker, PGNExportWorker
from src.core.eco import ECOManager
from src.core.db_manager import DBManager
from src.core.game_controller import GameController
from src.ui.board import ChessBoard
from src.ui.settings_dialog import SettingsDialog
from src.ui.search_dialog import SearchDialog
from src.ui.edit_game_dialog import EditGameDialog
from src.ui.widgets.results_bar import ResultsWidget
from src.ui.widgets.eval_graph import EvaluationGraph
from src.ui.widgets.analysis_report import AnalysisReport
from src.ui.widgets.game_info_header import GameInfoHeader
from src.ui.widgets.db_sidebar import DBSidebar
from src.ui.widgets.opening_tree_table import OpeningTreeTable
from src.ui.styles import (STYLE_EVAL_BAR, STYLE_LABEL_EVAL, STYLE_TABLE_HEADER, 
                       STYLE_PROGRESS_BAR, STYLE_BADGE_NORMAL, STYLE_BADGE_SUCCESS, 
                       STYLE_BADGE_ERROR, STYLE_GAME_HEADER)
from src.core.engine_worker import EngineWorker, FullAnalysisWorker

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("fa-chess")
        self.setStyleSheet(LIGHT_STYLE)
        
        # Gestores y Controladores
        self.db = DBManager()
        self.game = GameController()
        self.eco = ECOManager(ECO_FILE)
        
        # Estado de Ordenación
        self.sort_col = None
        self.sort_desc = False
        self.col_mapping = {0: "id", 1: "date", 2: "white", 3: "w_elo", 4: "black", 5: "b_elo", 6: "result"}
        
        self.game_evals = [] # Almacenar evaluaciones de la partida actual
        
        # Conectar señales del controlador de juego
        self.game.position_changed.connect(self.update_ui)
        
        # Conectar señales del gestor de base de datos
        self.db.active_db_changed.connect(self.refresh_db_list)
        self.db.active_db_changed.connect(self.update_stats) # Refrescar vía timer (seguro)
        
        self.db.filter_updated.connect(self.refresh_db_list)
        self.db.filter_updated.connect(self.update_stats) # Refrescar vía timer (seguro)
        
        # Temporizador para debouncing de estadísticas (evita lag)
        self.stats_timer = QTimer()
        self.stats_timer.setSingleShot(True)
        self.stats_timer.timeout.connect(self.run_stats_worker)
        
        self.load_config() 
        self.init_ui()
        self.init_menu()
        self.init_shortcuts()
        self.update_ui() # Cargar árbol y tablero inicial
        self.statusBar().showMessage("Listo")

    def init_shortcuts(self):
        QShortcut(QKeySequence(Qt.Key_Left), self, self.game.step_back)
        QShortcut(QKeySequence(Qt.Key_Right), self, self.game.step_forward)
        QShortcut(QKeySequence(Qt.Key_Home), self, self.game.go_start)
        QShortcut(QKeySequence(Qt.Key_End), self, self.game.go_end)
        QShortcut(QKeySequence("F"), self, self.flip_boards)
        QShortcut(QKeySequence("E"), self, self.toggle_engine_shortcut)
        QShortcut(QKeySequence("S"), self, self.search_current_position)

    def flip_boards(self):
        self.board_ana.flip()

    def search_current_position(self):
        import chess.polyglot
        pos_hash = chess.polyglot.zobrist_hash(self.game.board)
        df = self.db.get_active_df()
        if df is None:
            self.statusBar().showMessage("No hay ninguna base de datos activa", 3000)
            return
        if "fens" not in df.columns:
            QMessageBox.warning(self, "Búsqueda por Posición", f"La base '{self.db.active_db_name}' no tiene el índice de posiciones.\n\nPor favor, vuelve a abrir el archivo PGN original para re-importarla.")
            return
        
        # Feedback visual de inicio
        QApplication.setOverrideCursor(Qt.WaitCursor)
        self.progress.setRange(0, 0)
        self.progress.show()
        self.statusBar().showMessage("Buscando posición en la base de datos...")
        QApplication.processEvents() # Forzar dibujado antes del cálculo pesado

        try:
            # Guardamos el estado completo para que la Lupa lo reconozca
            self.search_criteria = {
                "white": "", "black": "", "min_elo": "", "result": "Cualquiera", 
                "position_hash": pos_hash,
                "use_position": True
            }
            
            filtered = self.db.filter_db(self.search_criteria)
            self.refresh_db_list(filtered)
            self.tabs.setCurrentIndex(1)
        finally:
            QApplication.restoreOverrideCursor()
            # La barra de progreso se ocultará cuando on_stats_finished termine su trabajo
            # No la ocultamos aquí para que el flujo sea continuo del filtro al árbol

    def init_ui(self):
        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)
        table_font = QFont("monospace", 9)

        # --- TAB 1: ANÁLISIS ---
        self.tab_analysis = QWidget()
        self.tabs.addTab(self.tab_analysis, "Tablero")
        ana_layout = QHBoxLayout(self.tab_analysis); ana_layout.setContentsMargins(0, 0, 0, 0)
        
        board_container = QWidget(); board_container_layout = QVBoxLayout(board_container)
        board_container_layout.setContentsMargins(0,0,0,0); board_container_layout.setSpacing(0)
        
        # Cabecera de Partida (Widget Refactorizado)
        self.game_header = GameInfoHeader()
        board_container_layout.addWidget(self.game_header)

        self.toolbar_ana = QToolBar(); self.toolbar_ana.setMovable(False); self.setup_toolbar(self.toolbar_ana)
        board_container_layout.addWidget(self.toolbar_ana)
        
        board_eval_layout = QHBoxLayout(); board_eval_layout.setSpacing(5)
        self.eval_bar = QProgressBar(); self.eval_bar.setOrientation(Qt.Vertical); self.eval_bar.setRange(-1000, 1000); self.eval_bar.setValue(0); self.eval_bar.setTextVisible(False); self.eval_bar.setFixedWidth(15); self.eval_bar.setStyleSheet(STYLE_EVAL_BAR); self.eval_bar.setVisible(False)
        self.board_ana = ChessBoard(self.game.board, self); self.board_ana.color_light, self.board_ana.color_dark = self.def_light, self.def_dark
        # Conectar señales de arrastre para evitar crashes con el motor
        self.board_ana.piece_drag_started.connect(lambda: setattr(self, 'is_dragging', True))
        self.board_ana.piece_drag_finished.connect(lambda: setattr(self, 'is_dragging', False))
        
                board_eval_layout.addWidget(self.eval_bar); board_eval_layout.addWidget(self.board_ana); board_container_layout.addLayout(board_eval_layout)
        
                ana_layout.addWidget(board_container)
        
                
        
                panel_ana = QWidget(); p_ana_layout = QVBoxLayout(panel_ana)
        
                
        
                # Restaurar Info Box (Estadísticas y Evaluación)
        
                info_box = QWidget(); info_layout = QHBoxLayout(info_box); info_layout.setContentsMargins(0, 0, 0, 0)
        
                self.label_pos_stats = QLabel("Partidas: 0")
        
                self.label_pos_stats.setStyleSheet(STYLE_BADGE_NORMAL); self.label_pos_stats.setAlignment(Qt.AlignCenter)
        
                self.label_eval = QLabel("")
        
                self.label_eval.setStyleSheet(STYLE_LABEL_EVAL)
        
                info_layout.addWidget(self.label_pos_stats, 1); info_layout.addWidget(self.label_eval)
        
                p_ana_layout.addWidget(info_box)
        
        
        
                # Árbol de Aperturas
        
                self.opening_tree = OpeningTreeTable()
        
                self.opening_tree.move_selected.connect(lambda uci: self.game.make_move(chess.Move.from_uci(uci)))
        
                self.opening_tree.move_hovered.connect(self.board_ana.set_hover_move)
        
                p_ana_layout.addWidget(self.opening_tree)
        
        # Panel de Pestañas (Notación / Gráfico)
        self.tabs_side = QTabWidget()
        
        # Pestaña 1: Notación
        # Panel de Pestañas (Notación / Gráfico)
        self.tabs_side = QTabWidget()
        
        # Pestaña 1: Notación
        tab_notacion = QWidget()
        layout_notacion = QVBoxLayout(tab_notacion)
        layout_notacion.setContentsMargins(0,0,0,0)
        
        self.hist_ana = QTextBrowser(); self.hist_ana.setOpenLinks(False); self.hist_ana.anchorClicked.connect(self.jump_to_move_link)
        layout_notacion.addWidget(self.hist_ana)
        
        # Barra de Herramientas de Partida (Acciones sobre la partida actual)
        game_actions_toolbar = QToolBar()
        game_actions_toolbar.setIconSize(QSize(16, 16))
        game_actions_toolbar.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        game_actions_toolbar.setStyleSheet("QToolBar { spacing: 10px; background: #f5f5f5; border-top: 1px solid #ddd; padding: 2px; }")
        
        act_save_active = QAction(qta.icon('fa5s.save', color='#1976d2'), "Guardar", self)
        act_save_active.setStatusTip("Guardar la partida actual en la base de datos seleccionada")
        act_save_active.setToolTip("Guardar en la base de datos activa")
        act_save_active.triggered.connect(self.save_to_active_db)
        game_actions_toolbar.addAction(act_save_active)
        
        act_save_clip = QAction(qta.icon('fa5s.clipboard', color='#2e7d32'), "a Clipbase", self)
        act_save_clip.setStatusTip("Copiar la partida actual al portapapeles interno (Clipbase)")
        act_save_clip.setToolTip("Añadir esta partida a la Clipbase (borrador)")
        act_save_clip.triggered.connect(self.add_to_clipbase)
        game_actions_toolbar.addAction(act_save_clip)
        
        spacer = QWidget(); spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        game_actions_toolbar.addWidget(spacer)
        
        act_new_game = QAction(qta.icon('fa5s.file'), "Nueva", self)
        act_new_game.setStatusTip("Limpiar el tablero y los datos para empezar una nueva partida desde cero")
        act_new_game.setToolTip("Limpiar tablero y empezar nueva partida")
        act_new_game.triggered.connect(self.start_new_game)
        game_actions_toolbar.addAction(act_new_game)
        
        layout_notacion.addWidget(game_actions_toolbar)
        
        self.tabs_side.addTab(tab_notacion, qta.icon('fa5s.list-ol'), "Notación")
        
        # Pestaña 3: Gráfico
        tab_grafico = QWidget()
        layout_grafico = QVBoxLayout(tab_grafico)
        layout_grafico.setContentsMargins(0,0,0,0)
        
        self.eval_graph = EvaluationGraph()
        self.eval_graph.move_selected.connect(self.game.jump_to_move) 
        layout_grafico.addWidget(self.eval_graph)
        
        # btn_analyze movido fuera
        
        self.tabs_side.addTab(tab_grafico, qta.icon('fa5s.chart-area'), "Gráfico")
        
        # Pestaña 3: Informe
        self.analysis_report = AnalysisReport()
        self.tabs_side.addTab(self.analysis_report, qta.icon('fa5s.chart-pie'), "Informe")
        
